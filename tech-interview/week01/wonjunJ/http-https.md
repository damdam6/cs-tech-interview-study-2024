## HTTP 통신의 특징과 HTTP와 HTTPS의 차이점

### HTTP 통신의 특징

- HTTP란? 인터넷에서 데이터(텍스트)를 주고 받을 수 있는 프로토콜
- request - response
    - **클라이언트-서버 구조**로 이루어져 있다.
    - 클라이언트가 HTTP 요청을 서버에 보내면, 서버는 요청을 처리한 후 결과에 따른 HTTP 응답을 클라이언트에게 보낸다
    - 클라이언트과 서버 사이의 소통은 평문(ASCII) 메시지로 이루어진다
- stateless(무상태 프로토콜)
    - HTTP에서는 서버가 클라이언트의 상태를 보존하지 않는다. 따라서 따라서 응답과 요청이 독립적
    - 장점
        - 무상태는 응답 서버를 쉽게 바꿀 수 있기 때문에 무한한 서버 증설이 가능하며 서버의 확장성이 높다.
        - 통신간의 연결 상태 처리나, 정보의 저장을 관리할 필요가 없어서 서버 디자인이 간단하다.
    - 단점
        - HTTP 요청을 보낼 때 마다 해당 요청을 처리하기 위한 모든 데이터를 매번 보내야 한다.
        - 이러한 한계로 인한 유저의 상태를 유지해야하는 서비스 같은 경우에는 쿠키나 세션을 사용해서 데이터를 처리
            - 꼬리질문 - 쿠키, 세션 그리고 토큰의 차이점
- Connectionless(비연결성)
    - 비연결성을 가지는 HTTP(1.0)에서는 실제로 요청을 주고받을 때만 연결을 유지하고 응답을 주고 나면 TCP/IP 연결을 끊는다. 이를 통해 최소한의 자원으로 서버를 유지할 수 있다.
        - 꼬리질문 - 이 HTTP의 비연결성으로 인한 문제는 무엇이며, 이를 극복하기 위한 방안은 어떤것이 있는가?
    - 장점
        - 일반적으로 초 단위 이하의 빠른 속도로 응답한다.
        - 비연결성의 특징은 트래픽이 많지 않고, 빠른 응답을 제공할 수 있는 경우 효율적으로 작동한다.
    - 단점
        - 트래픽이 많은 서비스를 운용할 때 비연결성은 한계를 보인다.
        - TCP/IP 연결을 새로 맺어야하므로 3 way handshake 시간이 추가된다.
            - 3 way handshake: 서버와 통신을 위해 신뢰성 있는 연결을 생성할때 수행하는 과정
            SYN → ACK/SYN → ACK
        - 브라우저로 사이트를 요청할 때 각각의 자원을 다운로드하기 위해 자원들을 보낼때 마다 연결을 끊고 다시 연결하고를 반복하는 것은 매우 비효율적이다.
            
            ![스크린샷 2024-06-18 오전 1.10.21.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3fec18b7-1fef-46b0-a8c1-e4a70adc3c9b/fc72ed98-04fa-485a-abd5-46fc873028bf/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-06-18_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.10.21.png)
            

### HTTP와 HTTPS의 차이

- HTTP (HyperText Transfer Protocol)
    - 데이터를 암호화하지 않고 텍스트 형태로 전송하기 때문에 보안에 취약
    - 기본적으로 80번 포트를 사용
    - SSL/TLS 암호화 과정이 없기 때문에 상대적으로 약간 빠를 수 있음
        - HTTPS를 쓰지 않고 HTTP를 경우가 있는가?
        HTTP가 약각 더 빠르기에 보안성이 크게 요구되지 않고 공개된 단순한 웹서핑이나 이런것들은 HTTP를 사용하는 경우도 있으나, 최근에는 최적화로 인해 성능 차이가 크지 않으므로 거의 HTTPS를 사용하는 추세
    - 기본적으로 TCP연결을 사용
- HTTPS (HyperText Transfer Protocol Secure)
    - HTTP에 SSL/TLS 인증서를 추가한 프로토콜로 보안이 강화된 형태
        - TLS는 Transport Layer Security의 줄임말로 과거 SSL에서 발전하며 이름이 변경된 것
    - SSL/TLS를 사용하여 데이터를 암호화한 후 전송
        - 꼬리질문 - 어떻게 암호화하기에 보안이 강화되는 것이 가능한가?
    - 기본적으로 443번 포트를 사용
    - 매번 SSL/TLS 암호화와 복호화 과정이 추가되기 때문에 약간의 성능 저하가 발생할 수 있다.
    - HTTPS를 지원한다고 해서 무조건 안전한 것은 아님
        - 이유: 신뢰할 수 있는 CA 기업이 아니라 자체적으로 인증서를 발급할 수도 있고, 신뢰할 수 없는 CA 기업을 통해서 인증서를 발급받을 수도 있기 때문

# 꼬리 질문

### 어떻게 암호화하기에 보안이 강화되는 것이 가능한가?

공개키 암호화 방식과 공개키의 느리다는 단점을 보완한 대칭키 암호화 방식을 함께 사용한다. 공개키 방식으로 대칭키를 전달하고, 서로 공유된 대칭키를 가지고 통신하게 된다.

### 이 HTTP의 비연결성으로 인한 문제는 무엇이며, 이를 극복하기 위한 방안은 어떤것이 있는가?

**극복 방안**

HTTP의 비연결성으로 인한 문제를 극복하기 위해 HTTP 1.1에서는 **Persistent connection**과 **Pipelining**, 2개의 연결 방식이 추가되었다.

**Persistent connection**은 연결의 지속 시간을 설정하는 것이다. 하지만 요청을 한 후에 응답을 기다려야만 하고 그 대기 시간 동안에는 아무것도 할 수가 없다는 문제점이 발생

**Pipelining**은 이를 개선한 모델로 클라이언트는 요청을 응답에 상관없이 보내고, 서버에서는 요청이 들어온 순서대로 보내준다.

하지만 이는 HTTP의 HOL(Heod Of Line) Blocking 문제를 발생시킨다. 

HTTP 2.0에서는 TCP연결이 성립된 후 N개의 스트림을 생성할 수 있는데 각 스트림은 고유식별자와 우선순위 정보가 있고, 양방향 데이터 흐름이 가능하다. 또한, HTTP 2.0에서는 HTTP의 요청, 응답 메세지를 프레임 단위로 나누고 바이너리 형식으로 인코딩한다. 이를 통해 각각의 HTTP 메세지를 하나 이상의 프레임으로 구성하여 각 프레임 단위로 보내주고, 프레임을 받은쪽에서는 스트림 식별자를 통해 프레임을 재조립하여 확인한다. 이를 **multiplex streaming**이라고 한다. 이를 이용해 HTTP의 HOL(Heod Of Line) Blocking 문제를 해결.

### 쿠키, 세션과 토큰의 차이점

**쿠키:** 브라우저에 key-value로 저장되는 데이터 파일로 유효기간내에는 브라우저가 종료되어도 계속 유지된다. 서버가 클라이언트로부터 요청을 받았을때 클라이언트의 정보를 바탕으로 쿠키를 만들고, 요청에 대한 응답을 보낼때 쿠키를 헤더에 담아 보낸다. 클라이언트는 응답을 받으면 브라우저는 쿠키를 쿠키 디렉터리에 저장 후 다음 요청때 사용한다.

**세션:** 세션은 쿠키를 이용하여 구현된다. 서버가 클라이언트를 구분하기 위해 응답에 쿠키를 포함할 때 session ID를 부여하고 클라이언트는 쿠키에 session ID를 저장해둔다. 클라이언트(사용자)의 정보를 브라우저에 저장하는 쿠키와 달리 세션은 클라이언트의 정보를 서버에 저장한다. 세션도 유효기간을 가지고 있지만 브라우저가 종료되면 만료기간에 상관없이 삭제된다.

토큰: 쿠키와 세션은 브라우저에 노출되어 위변조가 일어날 수 있어 보안상 문제가 있지만, 토큰(JWT)은 서명고 함께 원본 데이터를 암호화하여 토큰을 생성하므로 이 토큰이 갈취되거나 위변조가 일어난다고 하더라도 암호화한 서명과 같지 않으면 요청이 성립되지 않으므로 보안성을 높인 기술이다.

출처:

https://jeong-pro.tistory.com/89

https://rachel-kwak.github.io/2021/03/08/HTTPS.html

[https://velog.io/@wlwl99/HTTP의-특징](https://velog.io/@wlwl99/HTTP%EC%9D%98-%ED%8A%B9%EC%A7%95)

https://dkrnfls.tistory.com/289

https://judahhh.tistory.com/46

## 참고

### 조금 더 자세한 HTTPS 통신 흐름

일단 공개키 저장소라고 부르던 곳이 원래 명칭은 CA(Certificate Authority)다.CA는 민간기업이지만 아무나 운영할 수 없고 신뢰성이 검증된 기업만 CA를 운영할 수 있다.

1. 먼저 애플리케이션 서버(A)는 HTTPS를 적용하기 위해서 공개키와 개인키를 만든다.
2. 그 다음에 신뢰할 수 있는 CA 기업을 선택하고 그 기업에 내 공개키를 관리해달라고 계약하고 돈을 지불한다.
3. 계약을 완료한 CA기업(인증기관)은 또 CA기업만의 공개키와 개인키가 있다. CA기업은 CA기업의 이름과 A서버의 공개키, 공개키의 암호화 방법 등의 정보를 담은 인증서를 만들고, 해당 인증서를 CA기업의 개인키로 암호화해서 A서버에게 제공한다.
4. 사용자가 사이트에 접속하면 A서버는 A서버의 공개키로 암호화된 HTTPS 요청이 아닌 요청(Request)이 오면 이 암호화된 인증서를 클라이언트에게 보낸다. 예를 들어, 웹 브라우저가 index.html 파일을 달라고 요청했다면, 서버의 정보를 인증 기관의 개인키로 암호화한 인증서를 받게 되는 것이다.
5. 세계적으로 신뢰할 수 있는 CA 기업의 공개키는 브라우저가 이미 알고 있다. 브라우저는 이미 알고 있던 인증기관의 공개키로 인증서를 해독하여 검증한다. 그러면 사이트의 정보와 서버의 공개키를 알 수 있게 된다. - (이 부분은 보안상의 의미는 없다. 단지 해당 서버로부터 온 응답임을 확신할 수 있게 된다.)
6. 이렇게 얻은 서버의 공개키로 대칭키를 암호화해서 다시 서버에 보낸다.
7. 서버는 개인키로 암호문을 복호화하여 대칭키를 얻게 되고, 이제 대칭키로 데이터를 주고받을 수 있게 된다.
