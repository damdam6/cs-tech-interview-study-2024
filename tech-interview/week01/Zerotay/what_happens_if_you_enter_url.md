# 주소창에 url을 입력했을 때 일어나는 과정
## 기본 답변
주소창에 url을 입력하면 실제로 요청을 날릴 정확한 주소를 알아내는 작업이 일어납니다. IP 주소를 입력했다면 해당 IP 주소로 바로 요청이 날아가고, 도메인 네임을 입력했을 경우 먼저 캐싱된 도메인인지 확인하여 IP 주소를 찾아내고자 합니다. 캐싱이 안 됐다면 도메인 서버에 질의를 날려 IP 주소를 받아옵니다.
정확한 주소를 알게 됐다면 해당 주소로 HTTP 겟 요청을 날려 html 파일을 받아오고, 추가적인 정적 리소스 파일을 요청을 날려 받아옵니다. 이를 토대로 브라우저는 사용자에게 보기 좋게 렌더링하여 출력합니다. 이때 비동기 통신을 통해 추가적으로 데이터를 받아오는 과정이 수반되기도 합니다. 이 경우 흔히 백엔드라고 부르는 WAS 서버에서 데이터를 받아 추가적으로 화면을 구성합니다.

# 꼬리 질문
## DNS에서 일어나는 과정을 아는가
DNS는 도메인 네임 서버라는 뜻으로 IP 주소를 사람이 보기 쉬운 이름으로 바꾸는 프로토콜을 말합니다. 이로부터 얻는 장점은 사람이 보기 쉽다는 것과, 변동 가능성이 있는 IP 주소와 다르게 고정된 주소를 사용자에게 전달할 수 있다는 것입니다.
도메인 네임 서버는 분산된 서버 구조를 가지고 있으며 전세계의 10개 가량의 루트 네임 서버와 그로부터 하위 네임을 가지는 서버들, 그 하위 네임을 가지는 서버들이 계층적으로 분산되어 있습니다. 도메인 이름을 통해 IP 주소를 알게 되는 원리는 다음과 같습니다.
먼저 루트 서버에 전체 네임을 질의합니다. 그러면 루트 서버는 해당 URL을 읽고 이를 해결할 수 있는 하위 네임 서버의 주소를 알려줍니다. 이 과정은 해당 네임 서버에서도 마찬가지로 일어나며, 가령 구글의 주소를 질의한다고 하면 전체 주소의 뒷부분부터 시작하여 차츰 타겟의 주소를 알려주는 방식입니다.
그러나 이러한 과정은 많은 트래픽을 유발하기에 대다수의 경우 DNS 정보는 캐싱됩니다. 캐싱은 브라우저, 호스트파일, 라우터, ISP의 영역에서 진행되며, 실제 DNS 질의는 루트 서버로 가기 전 위의 영역을 거치기 전에 대부분 캐싱된 정보를 바탕으로 접속할 수 있게 됩니다.

## 페이지는 어떻게 렌더링되는가
렌더링은 HTML, CSS, JS와 같은 정적 리소스를 통해 진행됩니다. 단일 html 파일이 브라우저에 도착한 이후 브라우저는 해당 파일의 정보를 통해 추가 요청을 통해 필요한 파일들을 받아옵니다. 이후 브라우저는 html 파싱을 통해 DOM 트리를 생성하고, CSS 파일을 파싱하여 CSSOM 트리를 생성합니다. 이 트리들을 종합하여 브라우저는 렌더 트리를 구축하고, 출력할 구조와 모양에 대한 정보를 구체화합니다.

## url과 uri의 차이는
URL은 Uniform Resource Locator의 약자로 네트워크 상의 리소스 주소를 말합니다. URI는 Uniform Resource Identifier로 인터넷에서 자원을 나타내는 식별자입니다. URI는 상위 집합에 해당하며, scheme(프로토콜), 사용자 정보, 호스트와 경로, 쿼리 등의 모든 정보를 담고 있습니다. 
사용자가 사용할 때는 흔히 URL을 통해 요청을 보내게 되며, 이는 사용자 정보를 명시하지 않습니다. 
## HTTPS가 붙는 경우는 언제인가
HTTPS는 보안 기능이 추가된 프로토콜로 TLS 인증을 거쳐서 요청이 송수신되는 서버임을 보장합니다. 네트워크 상에서 돌아다니는 패킷은 쉽게 탈취가 가능하여 보안 정보가 탈취당할 우려가 있지만 HTTPS 프로토콜을 통한 요청은 패킷의 내용이 암호화되기 때문에 중간자의 스니핑으로부터 안전합니다. 신뢰되는 CA의 인증서를 받은 서버에 클라이언트는 공개키 알고리즘을 통해 정보를 암호화하게 되는데, 중간자가 송수신의 매개 역할을 하는 중간자 공격으로부터 안전할 수 있습니다. 이는 공개키 알고리즘을 통해 디지털 서명을 하여 신뢰되는 기관에 의해 인증받았다는 것을 입증할 수 있기 때문입니다.
## HTTP 프로토콜은 어떤 하위 프로토콜을 통해 이뤄지나
HTTP 프로토콜의 하위에서는 TCP 프로토콜이 진행되며 이는 전송 계층에서 발생합니다. TCP는 연결을 지향하는 프로토콜로, 모든 데이터가 순서대로 완전히 전송되는 것을 보장합니다. 이를 위해 TCP는 3 웨이 핸드쉐이크 과정을 통해 논리회선을 연결합니다. 
3웨이 핸드쉐이크는 클라이언트가 SYN 신호를 보내고, 서버는 해당 신호에 대한 ACK를, 그리고 다시 클라이언트가 이에 대한 ACK를 송신하는 것으로 체결됩니다. 이 동안 에러와 흐름, 혼잡을 제어할 방법과 양식이 설정됩니다. 
## WAS 서버가 필요한 이유
페이지가 렌더링되기 위해서는 많은 데이터가 필요하며 이는 싱글 스레드를 통해 진행되기에 통상 많은 시간이 소요됩니다. 이를 해결하기 위해 페이지가 렌더링된 이후 내부를 채우는 데이터만 따로 요청을 보내 채우는 것이 가능합니다. 이 과정은 비동기로 이뤄지며 이를 통해 페이지가 새로고침되지 않더라도 실시간으로 페이지가 변동되는 것이 가능합니다.

# 상세 정리
- [[DNS]]
	- 호스트파일, 
	- 라우팅 테이블
- 페이지 렌더링 원리
- tcp/ip
- was 서버

# 참고 정리
- https://velog.io/@zioo/%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-www.google.com-%EC%9D%84-%EC%9E%85%EB%A0%A5%ED%96%88%EC%9D%84-%EB%95%8C-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EA%B3%BC%EC%A0%95
- https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work
- DNS
	- 리커시브, 반복 dns 차이
		- https://www.akamai.com/ko/glossary/what-is-recursive-dns#accordion-962c34aeb8-item-4cf87b9d3a
	- dns 세부 동작 원리
		- https://wonsjung.tistory.com/614
- 렌더링 원리
	- https://opendeveloper.tistory.com/entry/FrontEnd-%EC%A7%80%EC%8B%9D%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%9B%90%EB%A6%AC%EC%99%80-%EC%88%9C%EC%84%9C%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B3%A0%EB%A0%A4%EC%82%AC%ED%95%AD
- TCP
	- https://itragdoll.tistory.com/57
	- https://ohaengsa.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-TCP-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%98-%EC%9D%B4%ED%95%B4
- URL
	- https://www.beusable.net/blog/?p=4507
	- https://velog.io/@h220101/URI-URL-%EA%B5%AC%EC%A1%B0-%EC%B0%A8%EC%9D%B4%EC%A0%90
