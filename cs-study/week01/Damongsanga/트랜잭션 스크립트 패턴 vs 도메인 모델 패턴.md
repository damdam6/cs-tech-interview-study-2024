# 트랜잭션 스크립트 패턴 vs 도메인 모델 패턴

태그: DDD
날짜: 2024년 6월 10일

## 트랜잭션 스크립트 패턴 vs 도메인 모델 패턴

1. **트랜잭션 스크립트 패턴**
   - 특징
     - **엔티티에 비즈니스로직이 거의 없고, 서비스 계층에서 비즈니스 로직을 처리하는 방법**
     - **엔티티는 DTO의 역할 만하고 위에 해당 비즈니스 로직이 서비스 계층으로 옮겨짐**
       - 도메인 엔티티는 아무런 비즈니스 로직이 없는 POJO 클래스로 데이터를 전달하는 역할만 수행
     - 하나의 트랜잭션으로 구성된 로직을 단일 함수/스크립트에서 처리
     - JSP에서 적용
   - 장점
     - 단순, 구현이 매우 쉬움
   - 단점
     - 비즈니스 로직이 복잡해질수록 난잡해짐
     - 분석, 설계에 대한 개념이 약함. 코드 중복 증가
     - 공통 모듈 분리 X
     - 서비스에 로직이 들어가면 테스트에 DB가 관여하기 때문에 테스트 하기가 POJO에 비해 어려워짐. 테스트가 DB 상태에 종속적이기 때문
2. **도메인 모델 패턴**
   - 특징
     - 객체 지향 분석 설계에 기반하여 구현하고자 하는 도메인(비즈니스) 모델을 생성하는 패턴
     - **서비스의 많은 로직이 엔티티로 이동하고, 서비스는 엔티티를 호출하는 정도의 얇은 비즈니스 로직을 가짐**
     - 데이터와 프로세스가 혼합되어있음
     - 객체간의 복잡한 연관관계
     - 도메인 모델과 데이터베이스 테이블 사이 매핑을 어떻게 처리할 것인가
   - 장점
     - 객체 지향에 기반한 재사용성, 확장성, 그리고 유지 보수의 편리함
     - 엔티티와 VO가 개념적으로 잘 정리됨
     - 비즈니스 전문가와 개발자 간의 의사소통이 원활
   - 단점
     - 도메인 모델 구축에 들어가는 노력

### 클린코드 6장

간단하게 책의 내용을 정리하자면, 시스템을 구현할 때 새로운 자료 타입을 추가하는 유연성이 필요하다면 객체를,

다른 경우로 새로운 동작을 추가하는 유연성이 필요하다면자료 전달 객체(ex. DTO)와 절차적인 코드가 더 적합 할 수도 있습니다.

### +a) [Spring에서 트랜잭션 스크립트 패턴을 써야하는 이유?](https://chem-en-9273.tistory.com/135)

**DB 커넥션을 잡고있는 시간 때문이다**

이 블로그에 따르면,

DB 커넥션 풀 자원 유한성 관점에서는 트랜잭션의 범위를 최소화해야한다

그런데 도메인 모델 패턴을 사용하는 경우 **엔티티를 로드하고, 여러 비즈니스 로직을 수행한 후, 변경된 엔티티를 저장하기까지의 시간이 길어지면 DB 커넥션을 잡고 있는 시간이 길어짐**

이와 달리 서비스단에서의 하나의 트랜잭션이 비즈니스로직을 담당하여 처리.

그 결과 **데이터베이스와의 상호작용을 빠르게 끝내고, 필요한 작업을 빠르게 처리하게 됨**

### **OSIV (Open-Session-In-View)**

**왼쪽은 OSIV ON, 오른쪽은 OSIV OFF**

![Untitled](../Damongsanga/트랜잭션%20스크립트%20패턴%20vs%20도메인%20모델%20패턴/Untitled.png)

![Untitled](../Damongsanga/트랜잭션%20스크립트%20패턴%20vs%20도메인%20모델%20패턴/Untitled%201.png)

- **HTTP 요청의 시작부터 끝까지 데이터베이스 세션을 열어두는 방식**
  - DB 커넥션 시작 시간부터 API 응답 끝날 때까지 영속성 컨텍스트와 데이터베이스 커넥션 유지
  - 영속성 컨텍스트의 연장
- **Hibernate와 같은 ORM에서 자주 사용되는 패턴**
  - **이 패턴의 주된 목적은 지연 로딩(Lazy Loading)을 적극 활용하기 위함**
- **이 방식은 뷰 렌더링 도중에도 엔티티에 접근할 수 있게 해주지만, 동시에 DB 커넥션을 더 오래 잡고 있게 만듬**
  - 실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 부족해질 수 있음
- **도메인 주도 개발 방식에서는 엔티티를 뷰에서 직접 접근할 일이 잦기 때문에 OSIV를 사용하는 경우가 많다. 이는 DB 커넥션을 오래 유지하게 되는 주요 원인이 됨**

### 해결방법

OSIV를 끈 채로 개발을 한다면 CQRS 패턴을 도입해볼 수 있는데,

이 과정에서 컨트롤러, 뷰단에서 지연 로딩을 사용하지 못하는 문제가 있다.

**이를 위해 쿼리 API가 들어오면 엔티티 대신 DTO로 반환하면 된다.**

장점으로 지연로딩 문제 예방, 성능 최적화, 데이터 보안, 유지보수성이 증가한다!

### 세부내용 1 (OSIV OFF)

- Spring에서는 개발 확장과 유연성을 위해 OSIV가 default로 켜져있다
- 그러나 트랜잭션 스크립트 패턴에서는 트랜잭션의 범위가 명확하게 서비스 단에서만 지속되도록 설계하는 것
- **원격 서비스를 많이 호출하거나 트랜잭션 컨텍스트 외부에서 많은 일이 발생하는 경우 OSIV를 모두 비활성화하는 것이 좋다.**
  ```yaml
  spring:
  	jpa:
  		open-in-view: false
  ```
- 그러나 OSIV를 아예 끄면 지연로딩을 할 수 없다
  - **OSIV 패턴을 비활성화하면, 트랜잭션이 종료될 때 영속성 컨텍스트도 함께 종료되므로, 트랜잭션 외부에서는 지연 로딩을 수행할 수 없게 된다.**
  - **이 경우, 지연 로딩은 트랜잭션 내부에서만 사용해야 한다**
- 따라서 특정 URL에서만 OSIV를 제외시켜주는 커스텀 필터를 적용해볼 수 있다
  - 자세한 내용은 [여기](https://velog.io/@haron/Spring-Connection-Pool-%EC%9D%B4-%EB%B6%80%EC%A1%B1%ED%95%98%EB%8B%A4%EA%B3%A0%EC%9A%94)

### 세부내용 2 (커맨드 & 쿼리 분리)

### **CQRS(Command Query Responsibility Segregation) 패턴**

1. 커맨드 (비즈니스 로직)
   - CUD
   - 정책적인 것임으로 잘 변경되지 않음
   - 특정 수의 엔티티를 등록, 수정하는 것임으로 성능 최적화가 크게 문제되지 않음
2. 조회 API
   - R
   - 자주 변동되고 라이프사이클이 빠름
   - 성능 최적화가 중요

**⇒ 서로 라이프 사이클이 다름으로 명확히 분리**

- 방법
  `OrderService` ⇒ 핵심 비즈니스 로직만
  `OrderQueryService` ⇒ 읽기 전용 트랜잭션을 사용한 쿼리용 API만
  - 프로젝트 규모가 작으면, 꼭 분리할 필요는 없다. `OrderService` 에 커맨드와 쿼리 모두 포함하되, 쿼리에는 `@Transactional(readOnly = true)` 를 지정할 수 있다.

### 참조

**클린코드 6. 객체와 자료구조**

[두 패턴의 차이](https://velog.io/@hellojihyoung/Design-Pattern-Domain-Model-Pattern-vs-Transaction-Script-Pattern)

[트랜잭션스크립트패턴을써야하는이유](https://chem-en-9273.tistory.com/135)

[김영한강사님답변](https://www.inflearn.com/questions/117315/%EB%B9%84%EC%A7%80%EB%8B%88%EC%8A%A4-%EB%A1%9C%EC%A7%81%EA%B5%AC%ED%98%84-entity-vs-service)

[OSIV관련](https://velog.io/@haron/Spring-Connection-Pool-%EC%9D%B4-%EB%B6%80%EC%A1%B1%ED%95%98%EB%8B%A4%EA%B3%A0%EC%9A%94)

[OSIV관련2](https://f-lab.kr/insight/understanding-osiv-in-spring-boot)

[OSIV관련3](https://dodeon.gitbook.io/study/kimyounghan-spring-boot-and-jpa-optimization/04-osiv)
